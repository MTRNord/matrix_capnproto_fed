using Go = import "/go.capnp";

@0xb8a1e7de8a3a89ec;

$Go.package("types");
$Go.import("github.com/MTRNord/matrix_protobuf_fed/proto/federation/v1/types");

# Broken right now. Hence inlined below
# using Json = import "/capnp/compat/json.capnp";

###############################################################################################################################

###############################################################################################################################
# Copied from https://github.com/capnproto/go-capnp/blob/0d218d2660ffa094198d7aba689c4eb04ff6ae18/std/capnp/compat/json.capnp #
###############################################################################################################################

struct JsonValue @0xb646fc9bdea8828e {
  union {
    # Standard JSON values.
    null @0 :Void;
    boolean @1 :Bool;
    number @2 :Float64;
    string @3 :Text;
    array @4 :List(JsonValue);
    object @5 :List(Field);

    # Non-standard: A "function call", applying a named function (named by a single identifier)
    # to a parameter list. Examples:
    #
    #     BinData(0, "Zm9vCg==")
    #     ISODate("2015-04-15T08:44:50.218Z")
    #
    # Mongo DB users will recognize the above as exactly the syntax Mongo uses to represent BSON
    # "binary" and "date" types in text, since JSON has no analog of these. This is basically the
    # reason this extension exists. We do NOT recommend using `call` unless you specifically need
    # to be compatible with some silly format that uses this syntax.
    call @6 :Call;
  }

  struct Field @0x99d8d8a8f49ec4f6 {
    name @0 :Text;
    value @1 :JsonValue;
  }

  struct Call @0x8c72e334d0537d39 {
    function @0 :Text;
    params @1 :List(JsonValue);
  }
}

###############################################################################################################################

# A generic map from keys to values.
struct Map(Key, Value) {
  entries @0 :List(Entry);
  struct Entry @0xb000b19244fa63f4 {
    key @0 :Key;
    value @1 :Value;
  }
}

###############################################################################################################################

# Defines a wrapper for signatures generated by a given server
struct Signature @0xbe04b152eaffa6c8 {
    server @0 :Text;
    signatures @1 :Map(Text, Data);
}

# This is the equivalent of https://spec.matrix.org/v1.9/server-server-api/#request-authentication
# Since capnproto rpc has no method like HTTP methods and no uris we instead use unique u64 ids for methods here.
# It is intentionally not an enum to account for the MSC process.
#
# It is also mandatory to convert any json content to a capnproto content on the wire to ensure it can be
# canonicalized and signed. It is by design a duplication of the data here between federation wire format and the
# Clientside json format. The wireformat however does not introduce any further restrictions on the event formats.
#
# This eliminates the need for json Canonicalization when signing.
struct AuthData @0xd9a283298fbeb191 {
    method @0 :UInt64;
    origin @1 :Text;
    destination @2 :Text;
    signatures @3 :List(Signature);
}

###############################################################################################################################

# The version data of a server.
# This is equivalent to the response in
# https://spec.matrix.org/v1.9/server-server-api/#server-implementation
struct ServerVersion @0xe833d93baba2deb6 {
    # Arbitrary name that identify this implementation.
    name @0 :Text;
    # Version of this implementation. The version format depends on the
    # implementation.
    version @1 :Text;
}

# The Key Query request body.
# The query criteria. The outer string key on the object is the server name 
# (eg: matrix.org). The inner string key is the Key ID to query for the 
# particular server. If no key IDs are given to be queried, the notary server
# should query for all keys. If no servers are given, the notary server must
# return an empty server_keys array in the response.
#
# The notary server may return multiple keys regardless of the Key IDs given.
struct QueryCriteria @0xbbc6594b64ec5041 {
    # A millisecond POSIX timestamp in milliseconds indicating when the
    # returned certificates will need to be valid until to be useful to
    # the requesting server.
    #
    # If not supplied, the current time as determined by the notary server is used.
    minimumValidUntilTS @0 :Int64;
}

# This response models the json response from
# https://spec.matrix.org/v1.9/server-server-api/#publishing-keys
struct ServerKeysResponse @0x91bc94026aa73194 {
    # Digital signatures for this object signed using the verify_keys.
    # The signature is calculated using the process described at [Signing
    # JSON](https://spec.matrix.org/v1.9/appendices/#signing-json).
    signatures @0 :List(Signature);

    struct Metadata @0xc6b8d5e8d14b4b9b {
        # **Required:** DNS name of the homeserver.
        serverName @0 :Text;

        # POSIX timestamp in milliseconds when the list of valid keys should be
        # refreshed. This field **MUST** be ignored in room versions 1, 2, 3,
        # and 4. Keys used beyond this timestamp **MUST** be considered invalid,
        # depending on the room version specification.
        # 
        # Servers **MUST** use the lesser of this field and 7 days into the future
        # when determining if a key is valid. This is to avoid a situation where an
        # attacker publishes a key which is valid for a significant amount of time
        # without a way for the homeserver owner to revoke it.
        validUntilTS @1 :Int64;
    }

    struct OldVerifyKey @0x956498bd24be9c30 {
        # **Required:** POSIX timestamp in milliseconds for when this key
        # expired.
        expiredTS @0 :Int64;
        # **Required:** The key as bytes. _DO NOT USE BASE64 HERE!_
        key @1 :Data;
    }

    union {
        # Anything that can be send outside of the individual key data
        metadata @1 :Metadata;

        # **Required:**
        # Public keys of the homeserver for verifying digital signatures.
        # 
        # The object’s key is the algorithm and version combined (`ed25519`
        # being the algorithm and `abc123` being the version). Together, this
        # forms the Key ID. The version must have characters matching the
        # regular expression `[a-zA-Z0-9_]`.
        verifyKeys @2 :Map(Text, Data);

        # The public keys that the server used to use and when it stopped using
        # them.
        # 
        # The object’s key is the algorithm and version combined (`ed25519` being
        # the algorithm and `0ldK3y` being the version).
        # Together, this forms the Key ID. The version must have characters
        # matching the regular expression `[a-zA-Z0-9_]`.
        oldVerifyKeys @3 :Map(Text, OldVerifyKey);
    }
}

struct Transaction @0x84bc4046c477cd59 {
    authData @0 :AuthData;

    # Metadata which we only require once
    struct Metadata @0xc97074bcbc8f1239 {
        # **Required:** The transaction ID.
        txnID @0 :Text;
        # **Required:** The server_name of the homeserver sending this transaction.
        origin @1 :Text;
        # **Required:** POSIX timestamp in milliseconds on originating homeserver
        # when this transaction started.
        originServerTS @2 :Int64;
    }

    struct EDU @0xa18f0aa774bf394b {
        # **Required:** The type of ephemeral message.
        eduType @0 :Text;
        # **Required:** The content of the ephemeral message.
        content @1 :JsonValue;
    }

    struct PDU @0xb1beb572e4d306be {
        struct EventReference @0xbb294824d9b4424b {
            union {
                eventID @0 :Text;
                sha256 @1 :Text;
            }
        }

        struct Unsigned @0x83ba1e25907bb64e {
            age @0 :UInt64;
        }

        union {
            roomVersion1 :group {
                depth @0 :UInt64;
                eventID @1 :Text;
                originServerTS @2 :Int64;
                roomID @3 :Text;
                sender @4 :Text;
                type @5 :Text;
                redacts @6 :Text;
                stateKey @7 :Text;
                content @8 :JsonValue;
                authEvents @9 :List(EventReference);
                prevEvents @10 :List(EventReference);
                hashes @11 :List(Text);
                signatures @12 :List(Signature);
                unsigned @13 :Unsigned;
            }
            roomVersion2 :group {
                depth @14 :UInt64;
                eventID @15 :Text;
                originServerTS @16 :Int64;
                roomID @17 :Text;
                sender @18 :Text;
                type @19 :Text;
                redacts @20 :Text;
                stateKey @21 :Text;
                content @22 :JsonValue;
                authEvents @23 :List(EventReference);
                prevEvents @24 :List(EventReference);
                hashes @25 :List(Text);
                signatures @26 :List(Signature);
                unsigned @27 :Unsigned;
            }
            roomVersion3 :group {
                depth @28 :UInt64;
                originServerTS @29 :Int64;
                roomID @30 :Text;
                sender @31 :Text;
                type @32 :Text;
                redacts @33 :Text;
                stateKey @34 :Text;
                content @35 :JsonValue;
                authEvents @36 :List(Text);
                prevEvents @37 :List(Text);
                hashes @38 :List(Text);
                signatures @39 :List(Signature);
                unsigned @40 :Unsigned;
            }
            roomVersion4 :group {
                depth @41 :UInt64;
                originServerTS @42 :Int64;
                roomID @43 :Text;
                sender @44 :Text;
                type @45 :Text;
                redacts @46 :Text;
                stateKey @47 :Text;
                content @48 :JsonValue;
                authEvents @49 :List(Text);
                prevEvents @50 :List(Text);
                hashes @51 :List(Text);
                signatures @52 :List(Signature);
                unsigned @53 :Unsigned;
            }
            roomVersion5 :group {
                depth @54 :UInt64;
                originServerTS @55 :Int64;
                roomID @56 :Text;
                sender @57 :Text;
                type @58 :Text;
                redacts @59 :Text;
                stateKey @60 :Text;
                content @61 :JsonValue;
                authEvents @62 :List(Text);
                prevEvents @63 :List(Text);
                hashes @64 :List(Text);
                signatures @65 :List(Signature);
                unsigned @66 :Unsigned;
            }
            roomVersion6 :group {
                depth @67 :UInt64;
                originServerTS @68 :Int64;
                roomID @69 :Text;
                sender @70 :Text;
                type @71 :Text;
                redacts @72 :Text;
                stateKey @73 :Text;
                content @74 :JsonValue;
                authEvents @75 :List(Text);
                prevEvents @76 :List(Text);
                hashes @77 :List(Text);
                signatures @78 :List(Signature);
                unsigned @79 :Unsigned;
            }
            roomVersion7 :group {
                depth @80 :UInt64;
                originServerTS @81 :Int64;
                roomID @82 :Text;
                sender @83 :Text;
                type @84 :Text;
                redacts @85 :Text;
                stateKey @86 :Text;
                content @87 :JsonValue;
                authEvents @88 :List(Text);
                prevEvents @89 :List(Text);
                hashes @90 :List(Text);
                signatures @91 :List(Signature);
                unsigned @92 :Unsigned;
            }
            roomVersion8 :group {
                depth @93 :UInt64;
                originServerTS @94 :Int64;
                roomID @95 :Text;
                sender @96 :Text;
                type @97 :Text;
                redacts @98 :Text;
                stateKey @99 :Text;
                content @100 :JsonValue;
                authEvents @101 :List(Text);
                prevEvents @102 :List(Text);
                hashes @103 :List(Text);
                signatures @104 :List(Signature);
                unsigned @105 :Unsigned;
            }
            roomVersion9 :group {
                depth @106 :UInt64;
                originServerTS @107 :Int64;
                roomID @108 :Text;
                sender @109 :Text;
                type @110 :Text;
                redacts @111 :Text;
                stateKey @112 :Text;
                content @113 :JsonValue;
                authEvents @114 :List(Text);
                prevEvents @115 :List(Text);
                hashes @116 :List(Text);
                signatures @117 :List(Signature);
                unsigned @118 :Unsigned;
            }
            roomVersion10 :group {
                depth @119 :UInt64;
                originServerTS @120 :Int64;
                roomID @121 :Text;
                sender @122 :Text;
                type @123 :Text;
                redacts @124 :Text;
                stateKey @125 :Text;
                content @126 :JsonValue;
                authEvents @127 :List(Text);
                prevEvents @128 :List(Text);
                hashes @129 :List(Text);
                signatures @130 :List(Signature);
                unsigned @131 :Unsigned;
            }
            roomVersion11 :group {
                depth @132 :UInt64;
                originServerTS @133 :Int64;
                roomID @134 :Text;
                sender @135 :Text;
                type @136 :Text;
                stateKey @137 :Text;
                content @138 :JsonValue;
                authEvents @139 :List(Text);
                prevEvents @140 :List(Text);
                hashes @141 :List(Text);
                signatures @142 :List(Signature);
                unsigned @143 :Unsigned;
            }
        }
    }

    union {
        # Anything that can be send outside of the individual key data
        metadata @1 :Metadata;

        # The ephemeral message to be sent.
        edu @2 :EDU;

        # The persistent message to be sent.
        pdu @3 :PDU;
    }
}

struct BackfillData @0xf2951513b06ace65 {
    struct Metadata {
        origin @0 :Text;
        originServerTS @1 :Int64;
    }

    union {
        # Anything that can be send outside of the individual key data
        metadata @0 :Metadata;
        pdu @1 :Transaction.PDU;
    }
}